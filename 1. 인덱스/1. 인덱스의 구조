인덱스의 구조
1. 인덱스의 구조
    
    Root Node : 가장 상위 노드이며 찾고자 하는 데이터를 탐색하기 위한 첫번째 단계이다. Branch Node 수 만큼 row를 가진다.
    
    Branch Node : Root 노드와  Leaf 사이에 존재하는 노드
    
    Leaf Node : KEY+ROWID 로 구성되어 있으며, Key 순서대로 *정렬* 되어있다. RowId는 DB Block의 Adress 정보를 가지고 있어서 데이터 값에 접근을 할 수 있다.
    
    ROWID : 데이터 오브젝트 번호 + 데이터파일번호 + 블록번호 + 로우번호로 구성되어 있다.
    
    수직적탐색 → 수평적스캔 → 테이블 Random Access
    
    수직적탐색 : 수직적 탐색은 Root -> Branch -> Leaf 노드로의 탐색하는 과정을 말한다. 이를 Random Access라고도 한다. 
   
    수평적탐색 : 수평적 탐색은 맨마지막인 Leaf 노드에서 정렬되어 있는 데이터들을 순차적으로 탐색하는 과정을 말한다. 이를 Sequencial Acess라고도 한다.
    
    ★인덱스를 구성하는 선두컬럼을 조건절에 사용
    
    Sequencial Acess(seq) vs Random Acess(Rand)
    
    1. seq는 순차적으로 정렬이 되어있기때문에 효율이 좋다.
    2. seq는 따라서 *적은 비용*을 갖는다.
    3. seq는 정렬된 데이터를 순차적으로 Full scan 한다.
    4. Mutiblock I/O 라고 불린다.
     -> 순차적으로 데이터들이 저장되어 있는 주소가 정리되어 있으므로, 그 데이터들이 저장되어 있는 주소의 블록(데이터들이 들어 있는 묶음)을 여러개 한번에 하드웨어에서 가져오기 때문에
     이는 뒤에서 더 자세하게 설명하겠음. 
     
     * 참고 : Disk I/O는 매우매우 효율과 성능이 떨어진다. 왜냐하면, Disk I/O는 저장되어 있는 데이터의 위치로 Disk Head가 이동을 하게되는데, 이는 물리적인 이동이라 시간이 매우 많이 소요가 된다. 
     이러한 이유때문에 모든 컴퓨터의 구조는 CPU와 Hard Disk 사이에 *메모리*를 이용하여 빠른 속도로 데이터를 I/O하게 된다. 따라서 물리적으로 데이터 베이스를 분산시키는게 무조건 효율측면에서 유리하다. 왜냐면 Disk Head 갯수가 늘어나기 때문.
     
     
     1. rand는 하나의 블록에서 하나의 Record(값)을 가져온다.
     2. 블록(데이터들이 저장되어 있는 집합소)를 방문했는데, 단 하나의 데이터만 가져오므로 효율이 낮고, 비용이 높다.
     3. Clustering Factor(CF)가 낮아야 성능이 좋다.
      -> Clustering Factor란 1번, 2번 ,3번 ... 순서로 데이터를 가져오는데 1,2,3 번이 모두 하나의 블록 안에 있으면 DB는 이를 미리 파악해서 다음번에는 해당하는 위치로 바로 이동하게 된다. 이는 탐색 수를 매우 낮출 수 있다. (뒤에서 더 자세하게 설명할 예정)
     4. Single Block I/O
      -> 하나의 블록에 방문해서 값을 가져오므로...
    
    
    

1. 인덱스의 탐색
    - 수직적탐색 : 읽고자하는 시작점 탐색, Random Access
    - 수평적스캔 : Leaf 블록의 시작점부터 종료점까지, Sequential Access

1. Sequential Access과 Random Access
    
    
    | Sequential Access | Random Access |
    | --- | --- |
    | - 하나의 블록에서 순차적으로 읽는다
    - Index Leaf Block 읽을때 / Full Scan 할 때
    - 적은비용
    - Full Scan일 경우 Multi-Block I/O가능 | - 주로 하나의 블록에서 하나의 레코드만 읽는다
    - Rowid 이용 테이블 액세스
    - DBA를 이용한 인덱스 수직적 탐색
    - 클러스터링팩터를 낮을때 높은 성능
    - Single Block I/O |
    
2. 인덱스 사용이 불가능하거나 Range Scan이 불가한경우
    - 인덱스 컬럼의 가공
    - Null의 검색
    - 묵시적 형변환 (컬럼과 상수의 데이터타입이 다른경우. 문자→숫자로 변환. Like 연산자에서는 숫자→문자로 변환
    - 부정검색

1. 인덱스 스캔방식
    - Index Range Scan : 인덱스를 구성하는 선두 컬럼을 조건절에 사용한 경우
    - Index Full Scan : 최종 결과 값이 적을때 Full Table Scan보다 효율적. 값이 많을 때는 Full Table Scan이 효율적
    - Index Unique Scan : unique인덱스일 때만 사용가능, =조건일때만 사용가능
    - Index Skip Scan : root까지 안가고 읽었던거에서 점프. 인덱스 선두컬럼의 Distinct가 매우 낮을 때 (ex성별) 사용. 인덱스 선두컬럼이 Between, Like, 부등호 일때도 사용가능
    - Index Fast Full Scan : 전체 인덱스를 Full Scan. Multi-Block I/O, 인덱스의 논리적 순서와 상관없이 물리적 순서대로 읽어서 속도가 빠르나 결과는 인덱스 키 컬럼 순서와 무관
        
        
        | Index Full Scan | Index Fast Full Scan |
        | --- | --- |
        | 1. 인덱스 구조를 따라 스캔
        2. 결과집합 순서 보장
        3. Single Block I/O
        4. 병렬스캔 불가
        5. 인덱스에 포함되지 않은 컬럼 조회시에도 사용 가능 | 1. 세그먼트 전체를 스캔
        2. 결과집합 순서 보장 안됨
        3. Multi-Block I/O
        4. 병렬스캔 가능
        5. 인덱스에 포함된 컬럼으로만 조회할 떄 사용가능 (Table Access안하고 인덱스만 읽음) |
    - Index Range Scan Desending : 찾고자하는 끝점에서 시작해서 탐색

1. 오라클 DBMS 구조
    
    오라클DB는 크게 인스턴스와 데이터베이스 영역으로 나뉨
    
    데이터베이스 영역에는 데이터파일, 컨트롤파일, 리두로그파일이 있고
    
    인스턴스영역에는 SGA와 백그라운드 프로세스가 있다.
    
    SGA에는 shared buffer, Data buffer cache, Redo Log Buffer가 있다
    
    대표적인 백그라운드 프로세스는 PMON, SMON, DBWR, LGWR, CKPT가 있다.
    
2. 테이블 Random Access 부하
    - Buffer Pinning (Logical Read Count로 잡히지않음)
        
        다음번 Read시 현재 읽은 동일한 Block을 읽을경우 블록이 Age-out되지 않도록 Pin을 걸어두고, 해당 주소가 가리키는 메노리주소를 PGA에 저장해서 바로 찾아가는 기법
        
    - 클러스터링 팩터
        
        특정컬럼을 기준으로 같은 값을 데이터가 서로 모여있는 정도를ㅓ 의미
        
        좋으면 블록수에 인접, 나쁘면 로우수에 인접
        
        Cost = Blevel + (리프 블록 수 * 유효 인덱스 선택도) + (클러스터링 팩터 * 유효 테이블 선택도)
        
        - Blevel: 리프 블록에 도달하기 전까지 읽게 될 루트 및 브랜치 블록 개수
        - 유효 인덱스 선택도: 전체 인덱스 레코드 중에서 조건절을 만족하는 레코드를 찾기 위해 스캔할 것으로 예상되는 비율
        - 유효 테이블 선택도: 전체 레코드 중에서 인덱스 스캔을 완료하고서 최종적으로 테이블을 방문할 것으로 예상되는 비율
        
    - IOT : 테이블을 인덱스 구조로 생성하는 것. 즉 테이블 블록에 있어야되는 데이터를 인덱스 리프 블록에 모두 저장
        
        크기가 작고 NL조인으로 반복 룩업하는 테이블에 활용
        
    1. 인덱스 스캔 효율
        
        점 (=, in) 선 (between)
        
        선 조회 컬럼은 가급적 인덱스 뒤 쪽으로, 선 조건 이후는 무조건 체크조건
        
        선 조건이 맨 끝에 있을수록 비효율이 낮음
        
        점조건으로 쓰인게 driving, 그 다음부터는 check조건이라고 볼 때, 점조건이 많을수록 매칭도가 높음.
        
        *결합인덱스 우선순위결정
        
         자주 사용되는가, =조건, 분포도(변별력 높은거), 소트연산 대체
        
    2. 인덱스 종류
        - 클러스터 인덱스 : 키 값이 같은 레코드가 한 블록에 모이도록 저장하는 구조.
            
            키 값은 항상 Unique, 키 값과 테이블 레코드 1:M 관계 유지
            
            클러스터링 팩터가 좋아서 넓은 범위 검색에 유리
            
            새로운 값이 자주 입력되거나 수정이 자주 발생하는 경우는 좋지 않음
